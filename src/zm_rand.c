/* ZM - Z's Mathematics Toolbox
 * Copyright (C) 1998 Tomomichi Sugihara (Zhidao)
 *
 * zm_rand - random number generator.
 */

#include <zm/zm_rand.h>

/* a random value generator based on the normal distribution based on Box-Muller's method. */
double zRandFND(double mu, double sigma)
{
  return mu + sigma * sqrt( -2.0*log(zRandF(zTOL,1)) ) * sin( zPIx2*zRandF(zTOL,1) );
}

/* ********************************************************** */
/* CLASS: zRandMT
 * Mersenne twister
 *
 * This implementation of Mersenne twister proposed by
 * M. Matsumoto and T. Nishimura (1995) is a simple
 * rearrangement of the code written by Mr. Isaku Wada.
 * The original sources zmtrand.{h,c} are available at:
 *  http://www001.upp.so-net.ne.jp/isaku/index.html
 * but, debugged uninitialized flag.
 * **********************************************************
 */

/* default history of Mersenne twister */
static zRandMT __zm_mt, *__zm_default_mt = NULL;

#define Z_RAND_MT_MAX  0xFFFFFFFFUL
#define Z_RAND_MT_MGC1 1812433253UL
#define Z_RAND_MT_MGC2 0x9908B0DFUL
#define Z_RAND_MT_MGC3 0x9D2C5680UL
#define Z_RAND_MT_MGC4 0xEFC60000UL
#define Z_RAND_MT_CYC1 227
#define Z_RAND_MT_CYC2 396
#define Z_RAND_MT_MASK 0x80000000UL

/* random value (32 bit, unsigned) generated by Mersenne twister. */
static ulong _zRandMTVal(zRandMT *mt)
{
  static ulong mag[] = { 0, Z_RAND_MT_MGC2 };
  ulong r;
  register int i;

  if( !mt && !( mt = __zm_default_mt ) ){
    zRandInitMT( NULL );
    mt = &__zm_mt;
  }
  if( ( i = mt->index ) == 0 ){
    for( ; i<Z_RAND_MT_CYC1; i++ ){
      r = ( mt->x[i]&Z_RAND_MT_MASK ) | ( mt->x[i+1]&~Z_RAND_MT_MASK );
      mt->x[i] = mt->x[i+Z_RAND_MT_CYC2+1]^(r>>1)^mag[r&1];
    }
    for( ; i<Z_RAND_MT_HISTORY; i++ ){
      r = ( mt->x[i]&Z_RAND_MT_MASK ) | ( mt->x[i+1]&~Z_RAND_MT_MASK );
      mt->x[i] = mt->x[i-Z_RAND_MT_CYC1  ]^(r>>1)^mag[r&1];
    } /* i = Z_RAND_MT_HISTORY */
      r = ( mt->x[i]&Z_RAND_MT_MASK ) | ( mt->x[0]  &~Z_RAND_MT_MASK );
      mt->x[i] = mt->x[  Z_RAND_MT_CYC2  ]^(r>>1)^mag[r&1];
    i=0;
  }
  r = mt->x[i];
  if( ++i > Z_RAND_MT_HISTORY ) i = 0;
  mt->index = i;
  /* twisting */
  r ^= (r>>11);
  r ^= (r<<7 ) & Z_RAND_MT_MGC3;
  r ^= (r<<15) & Z_RAND_MT_MGC4;
  r ^= (r>>18);
  return r;
}

/* initialize Mersenne twister. */
void zRandInitMT(zRandMT *mt)
{
  static ulong seed;
  register uint i;

  seed = time( NULL );
  if( mt == NULL )
    mt = __zm_default_mt = &__zm_mt;
  else
    seed++;
  for( mt->x[0]=(seed&=Z_RAND_MT_MAX), i=1; i<=Z_RAND_MT_HISTORY; i++ )
    mt->x[i] = seed
      = ( Z_RAND_MT_MGC1 * (seed^(seed>>30)) + i ) & Z_RAND_MT_MAX;
  mt->index = 0;
  for( i=0; i<Z_RAND_MT_HISTORY; i++ )
    _zRandMTVal( mt ); /* skip the first Z_RAND_MT_HISTORY numbers. */
  /* for normal distribution */
  mt->nd_sw = false;
  mt->nd_last = 0;
}

/* random integer number by Mersenne twister. */
int zRandMTI(zRandMT *mt, int min, int max)
{
  return _zRandMTVal( mt ) % ( max - min + 1 ) + min;
}

/* random double-precision floating-point number by Mersenne twister. */
double zRandMTF(zRandMT *mt, double min, double max)
{
  return (double)_zRandMTVal( mt ) / Z_RAND_MT_MAX * ( max - min ) + min;
}

/* random [0,1] double-precision floating-point number by Mersenne twister. */
double zRandMTN(zRandMT *mt)
{
  return (double)_zRandMTVal( mt ) / Z_RAND_MT_MAX;
}

/* random [0,1) double-precision floating-point number by Mersenne twister. */
double zRandMTNU(zRandMT *mt)
{
  return (double)_zRandMTVal( mt ) / ( (double)Z_RAND_MT_MAX + 1 );
}

/* ********************************************************** */
/* a variety of random distributions
 * ********************************************************** */

/* gamma distribution family */

/* gamma distribution. */
double zRandGamma(zRandMT *mt, double a)
{
  double t, u, x, y;

  if( a > 1 ){
    a -= 1.0;
    t = sqrt(2*a+1);
    do{
      do{
        do{
          x = 1 - zRandMTN(mt);
          y = 2 * zRandMTN(mt) - 1;
        } while( x*x+y*y > 1 );
        y /= x;
        x = t*y + a;
      } while( x <= 0 );
      u = a * log(x/a) - t*y;
    } while( u<-50 || zRandMTN(mt) > (1+y*y)*exp(u) );
  } else{
    t = zE / ( a + zE );
    do{
      if( zRandMTN(mt) < t ){
        x = pow( zRandMTN(mt), 1/a );
        y = exp(-x);
      } else {
        x = 1 - log( 1 - zRandMTN(mt) );
        y = pow( x, a-1 );
      }
    } while( zRandMTN(mt) >= y );
  }
  return x;
}

/* Chi squared distribution. */
double zRandChiSqr(zRandMT *mt, double nu)
{
  return 2 * zRandGamma( mt, 0.5*nu );
}

/* beta distribution. */
double zRandBeta(zRandMT *mt, double a, double b)
{
  double x;

  x = zRandGamma(mt,a);
  return x / ( x + zRandGamma(mt,b) );
}

/* F distribution. */
double zRandFD(zRandMT *mt, double a, double b)
{
  double x1, x2;

  x1 = zRandChiSqr(mt,a);
  x2 = zRandChiSqr(mt,b);
  return (x1*b) / (x2*a);
}

/* normal distribution. */
double zRandND(zRandMT *mt)
{
  double t, u;

  if( !mt ) mt = __zm_default_mt;
  if( !mt->nd_sw ){
    t = sqrt( -2*log( 1-zRandMTNU(mt) ) );
    u = zPIx2*zRandMTNU(mt);
    mt->nd_last = t * sin(u);
    mt->nd_sw = true;
    return t * cos(u);
  }
  mt->nd_sw = false;
  return mt->nd_last;
}

/* t distribution. */
double zRandT(zRandMT *mt, double n)
{
  double a, b, c;

  if( n <= 2 ){
    do{
      a = zRandChiSqr(mt,n);
    } while( zIsTiny(a) );
    return zRandND(mt) / sqrt(a/n);
  }
  do{
    a = zRandND(mt);
    b = a*a / (n-2);
    c = log( 1 - zRandMTNU(mt) ) / ( 1 - 0.5*n );
  } while( exp(-b-c) > 1-b );
  return a / sqrt( (1-2.0/n) * (1-b) );
}

/* continuous distribution */

/* exponential distribution with unit meanvalue. */
double zRandExp(zRandMT *mt)
{
  return -log( 1 - zRandMTNU(mt) );
}

/* logistic distribution. */
double zRandLog(zRandMT *mt)
{
  double r;

  do{
    r = zRandMTNU(mt);
  } while( zIsTiny(r) );
  return log( r / (1-r) );
}

/* power distribution. */
double zRandPower(zRandMT *mt, double n)
{
  return pow( zRandMTNU(mt), 1.0/(n+1) );
}

/* triangle distribution. */
double zRandTri(zRandMT *mt)
{
  return zRandMTN(mt) - zRandMTN(mt);
}

/* Cauchy's distribution. */
double zRandCauchy(zRandMT *mt)
{
  double x, y;

  do{
    x = 1 - zRandMTF(mt,0,1);
    y = 2 * zRandMTF(mt,0,1)-1;
  } while( x*x + y*y > 1 );
  return y/x;
}

/* Weibull distribution. */
double zRandWeibull(zRandMT *mt, double alpha)
{
  return pow( -log( 1 - zRandMTNU(mt) ), 1/alpha );
}

/* discrete distribution */

/* binomial distribution. */
int zRandBinom(zRandMT *mt, int n, double p)
{
  register int i, r;

  for( r=0, i=0; i<n; i++ )
    if( zRandMTN(mt) < p ) r++;
  return r;
}

/* two-variable binomial distribution with relation. */
void zRandBinom2(zRandMT *mt, double r, double *x, double *y)
{
  double r1, r2, s;

  do{
    r1 = 2 * zRandMTNU(mt) - 1;
    r2 = 2 * zRandMTNU(mt) - 1;
    s = r1*r1 + r2*r2;
  } while( s > 1 || zIsTiny(s) );
  s = -log(s) / s;
  r1 = sqrt( (1+r)*s ) * r1;
  r2 = sqrt( (1-r)*s ) * r2;
  *x = r1+r2;
  *y = r1-r2;
}

/* Poisson's distribution. */
int zRandPoisson(zRandMT *mt, double lambda)
{
  int i;

  lambda = exp(lambda) * zRandMTF(mt,0,1);
  for( i=0; lambda>1; i++ )
    lambda *= zRandMTF(mt,0,1);
  return i;
}

/* geometric distribution. */
int zRandGeo(zRandMT *mt, double p)
{
  return (int)ceil( log(1-zRandMTNU(mt)) / log(1-p) );
}
