/* ZM - Z's Mathematics Toolbox
 * Copyright (C) 1998 Tomomichi Sugihara (Zhidao)
 *
 * zm_rand - random number generator.
 */

#include <zm/zm_rand.h>

/* zRandFND
 * - a random value generator based on the normal distribution.
 */
double zRandFND(double mu, double sigma)
{
  return mu + sigma * sqrt( -2.0*log(zRandF(zTOL,1)) ) * sin( zPIx2*zRandF(zTOL,1) );
}

/* ********************************************************** */
/* CLASS: zRandMT
 * Mersenne twister
 *
 * This implementation of Mersenne twister proposed by
 * M. Matsumoto and T. Nishimura (1995) is a simple
 * rearrangement of the code written by Mr. Isaku Wada.
 * The original sources zmtrand.{h,c} are available at:
 *  http://www001.upp.so-net.ne.jp/isaku/index.html
 * but, debugged uninitialized flag.
 * **********************************************************
 */

/* default history of Mersenne twister */
static zRandMT __zm_mt, *__zm_default_mt = NULL;
static ulong _zRandMTVal(zRandMT *mt);

#define Z_RAND_MT_MAX  0xFFFFFFFFUL
#define Z_RAND_MT_MGC1 1812433253UL
#define Z_RAND_MT_MGC2 0x9908B0DFUL
#define Z_RAND_MT_MGC3 0x9D2C5680UL
#define Z_RAND_MT_MGC4 0xEFC60000UL
#define Z_RAND_MT_CYC1 227
#define Z_RAND_MT_CYC2 396
#define Z_RAND_MT_MASK 0x80000000UL

/* zRandInitMT
 * - initialize Mersenne twister.
 */
void zRandInitMT(zRandMT *mt)
{
  static ulong seed;
  register uint i;

  seed = time( NULL );
  if( mt == NULL )
    mt = __zm_default_mt = &__zm_mt;
  else
    seed++;
  for( mt->x[0]=(seed&=Z_RAND_MT_MAX), i=1; i<=Z_RAND_MT_HISTORY; i++ )
    mt->x[i] = seed
      = ( Z_RAND_MT_MGC1 * (seed^(seed>>30)) + i ) & Z_RAND_MT_MAX;
  mt->index = 0;
  for( i=0; i<Z_RAND_MT_HISTORY; i++ )
    _zRandMTVal( mt ); /* skip the first Z_RAND_MT_HISTORY numbers. */
  /* for normal distribution */
  mt->nd_sw = false;
  mt->nd_last = 0;
}

/* (static)
 * _zRandMTVal
 * - random value (32 bit, unsigned) generated by Mersenne twister.
 */
ulong _zRandMTVal(zRandMT *mt)
{
  static ulong mag[] = { 0, Z_RAND_MT_MGC2 };
  ulong r;
  register int i;

  if( !mt && !( mt = __zm_default_mt ) ){
    zRandInitMT( NULL );
    mt = &__zm_mt;
  }
  if( ( i = mt->index ) == 0 ){
    for( ; i<Z_RAND_MT_CYC1; i++ ){
      r = ( mt->x[i]&Z_RAND_MT_MASK ) | ( mt->x[i+1]&~Z_RAND_MT_MASK );
      mt->x[i] = mt->x[i+Z_RAND_MT_CYC2+1]^(r>>1)^mag[r&1];
    }
    for( ; i<Z_RAND_MT_HISTORY; i++ ){
      r = ( mt->x[i]&Z_RAND_MT_MASK ) | ( mt->x[i+1]&~Z_RAND_MT_MASK );
      mt->x[i] = mt->x[i-Z_RAND_MT_CYC1  ]^(r>>1)^mag[r&1];
    } /* i = Z_RAND_MT_HISTORY */
      r = ( mt->x[i]&Z_RAND_MT_MASK ) | ( mt->x[0]  &~Z_RAND_MT_MASK );
      mt->x[i] = mt->x[  Z_RAND_MT_CYC2  ]^(r>>1)^mag[r&1];
    i=0;
  }
  r = mt->x[i];
  if( ++i > Z_RAND_MT_HISTORY ) i = 0;
  mt->index = i;
  /* twisting */
  r ^= (r>>11);
  r ^= (r<<7 ) & Z_RAND_MT_MGC3;
  r ^= (r<<15) & Z_RAND_MT_MGC4;
  r ^= (r>>18);
  return r;
}

/* zRandMTI
 * - integer random number by Mersenne twister.
 */
int zRandMTI(zRandMT *mt, int min, int max)
{
  return _zRandMTVal( mt ) % ( max - min + 1 ) + min;
}

/* zRandMTF
 * - double-precision floating-point random number by Mersenne twister.
 */
double zRandMTF(zRandMT *mt, double min, double max)
{
  return (double)_zRandMTVal( mt ) / Z_RAND_MT_MAX * ( max - min ) + min;
}

/* zRandMTN
 * - [0,1] double-precision floating-point random number by Mersenne twister.
 */
double zRandMTN(zRandMT *mt)
{
  return (double)_zRandMTVal( mt ) / Z_RAND_MT_MAX;
}

/* zRandMTNU
 * - [0,1) double-precision floating-point random number by Mersenne twister.
 */
double zRandMTNU(zRandMT *mt)
{
  return (double)_zRandMTVal( mt ) / ( (double)Z_RAND_MT_MAX + 1 );
}

/* ********************************************************** */
/* a variety of random distributions
 * ********************************************************** */

/* gamma distribution family */

/* zRandGamma
 * - gamma distribution.
 */
double zRandGamma(zRandMT *mt, double a)
{
  double t, u, x, y;

  if( a > 1 ){
    a -= 1.0;
    t = sqrt(2*a+1);
    do{
      do{
        do{
          x = 1 - zRandMTN(mt);
          y = 2 * zRandMTN(mt) - 1;
        } while( x*x+y*y > 1 );
        y /= x;
        x = t*y + a;
      } while( x <= 0 );
      u = a * log(x/a) - t*y;
    } while( u<-50 || zRandMTN(mt) > (1+y*y)*exp(u) );
  } else{
    t = zE / ( a + zE );
    do{
      if( zRandMTN(mt) < t ){
        x = pow( zRandMTN(mt), 1/a );
        y = exp(-x);
      } else {
        x = 1 - log( 1 - zRandMTN(mt) );
        y = pow( x, a-1 );
      }
    } while( zRandMTN(mt) >= y );
  }
  return x;
}

/* zRandChiSqr
 * - Chi squared distribution.
 */
double zRandChiSqr(zRandMT *mt, double nu)
{
  return 2 * zRandGamma( mt, 0.5*nu );
}

/* zRandBeta
 * - beta distribution.
 */
double zRandBeta(zRandMT *mt, double a, double b)
{
  double x;

  x = zRandGamma(mt,a);
  return x / ( x + zRandGamma(mt,b) );
}

/* zRandFD
 * - F distribution.
 */
double zRandFD(zRandMT *mt, double a, double b)
{
  double x1, x2;

  x1 = zRandChiSqr(mt,a);
  x2 = zRandChiSqr(mt,b);
  return (x1*b) / (x2*a);
}

/* normal distribution */

/* zRandNormal
 * - normal distribution.
 */
double zRandNormal(zRandMT *mt)
{
  double t, u;

  if( !mt ) mt = __zm_default_mt;
  if( !mt->nd_sw ){
    t = sqrt( -2*log( 1-zRandMTNU(mt) ) );
    u = zPIx2*zRandMTNU(mt);
    mt->nd_last = t * sin(u);
    mt->nd_sw = true;
    return t * cos(u);
  }
  mt->nd_sw = false;
  return mt->nd_last;
}

/* zRandT
 * - t distribution.
 */
double zRandT(zRandMT *mt, double n)
{
  double a, b, c;

  if( n <= 2 ){
    do{
      a = zRandChiSqr(mt,n);
    } while( zIsTiny(a) );
    return zRandNormal(mt)/sqrt(a/n);
  }
  do{
    a = zRandNormal(mt);
    b = a*a / (n-2);
    c = log( 1 - zRandMTNU(mt) ) / ( 1 - 0.5*n );
  } while( exp(-b-c) > 1-b );
  return a / sqrt( (1-2.0/n) * (1-b) );
}

/* continuous distribution */

/* zRandExp
 * - exponential distribution with unit meanvalue.
 */
double zRandExp(zRandMT *mt)
{
  return -log( 1 - zRandMTNU(mt) );
}

/* zRandLog
 * - logistic distribution.
 */
double zRandLog(zRandMT *mt)
{
  double r;

  do{
    r = zRandMTNU(mt);
  } while( zIsTiny(r) );
  return log( r / (1-r) );
}

/* zRandPower
 * - power distribution.
 */
double zRandPower(zRandMT *mt, double n)
{
  return pow( zRandMTNU(mt), 1.0/(n+1) );
}

/* zRandTri
 * - triangle distribution.
 */
double zRandTri(zRandMT *mt)
{
  return zRandMTN(mt) - zRandMTN(mt);
}

/* zRandCauchy
 * - Cauchy's distribution.
 */
double zRandCauchy(zRandMT *mt)
{
  double x, y;

  do{
    x = 1 - zRandMTF(mt,0,1);
    y = 2 * zRandMTF(mt,0,1)-1;
  } while( x*x + y*y > 1 );
  return y/x;
}

/* zRandWeibull
 * - Weibull distribution.
 */
double zRandWeibull(zRandMT *mt, double alpha)
{
  return pow( -log( 1 - zRandMTNU(mt) ), 1/alpha );
}

/* discrete distribution */

/* zRandBinom
 * - binomial distribution.
 */
int zRandBinom(zRandMT *mt, int n, double p)
{
  register int i, r;

  for( r=0, i=0; i<n; i++ )
    if( zRandMTN(mt) < p ) r++;
  return r;
}

/* zRandBinom2
 * - two-variable binomial distribution with relation.
 */
void zRandBinom2(zRandMT *mt, double r, double *x, double *y)
{
  double r1, r2, s;

  do{
    r1 = 2 * zRandMTNU(mt) - 1;
    r2 = 2 * zRandMTNU(mt) - 1;
    s = r1*r1 + r2*r2;
  } while( s > 1 || zIsTiny(s) );
  s = -log(s) / s;
  r1 = sqrt( (1+r)*s ) * r1;
  r2 = sqrt( (1-r)*s ) * r2;
  *x = r1+r2;
  *y = r1-r2;
}

/* zRandPoisson
 * - Poisson's distribution.
 */
int zRandPoisson(zRandMT *mt, double lambda)
{
  int i;

  lambda = exp(lambda) * zRandMTF(mt,0,1);
  for( i=0; lambda>1; i++ )
    lambda *= zRandMTF(mt,0,1);
  return i;
}

/* zRandGeo
 * - geometric distribution.
 */
int zRandGeo(zRandMT *mt, double p)
{
  return (int)ceil( log(1-zRandMTNU(mt)) / log(1-p) );
}
